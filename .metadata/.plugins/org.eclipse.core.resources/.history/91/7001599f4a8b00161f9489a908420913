/**
 * Licensed to the Sakai Foundation (SF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The SF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
package org.apache.sling.contrib.ldap.internal;

import org.apache.sling.contrib.ldap.api.LdapConnectionManager;
import org.apache.sling.contrib.ldap.api.LdapConnectionManagerConfig;
import org.ldaptive.Connection;
import org.ldaptive.DefaultConnectionFactory;
import org.ldaptive.LdapException;
import org.ldaptive.pool.PooledConnectionFactory;
import org.ldaptive.pool.SoftLimitConnectionPool;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.UnsupportedEncodingException;

/**
 */
public class PoolingLdapConnectionManager implements LdapConnectionManager {

	/** Class-specific logger */
	private static Logger log = LoggerFactory.getLogger(PoolingLdapConnectionManager.class);
	
	/** Whether to create secure connections. */
	public final static String LDAP_CLIENT_PROP_SECURECONNECTION = "secureConnection";
	public final static boolean DEFAULT_LDAP_CLIENT_PROP_SECURECONNECTION = false;
	
	/** Where to connect using TLS. */
	public final static String LDAP_CLIENT_PROP_KEYSTORELOCATION = "keystoreLocation";
	public final static String LDAP_CLIENT_PROP_KEYSTORELOCATION = "";	  

	  
	  private boolean tls;

	  /** Where the keystore is located. */
	  private String keystoreLocation;

	  /** The password to the keystore. */
	  private String keystorePassword;

	  /** Timeout (in milliseconds) for an operation. */
	  private int operationTimeout = 5000;

	  /** The host to which to connect. */
	  private String ldapHost;

	  /** The port on which to connect. */
	  private int ldapPort = 1389;

	  /** The user/account to use for connections. */
	  private String loginUser;

	  /** The password to use for connection logins. */
	  private String loginPassword;

	  /** Whether to follow referrals. */
	  private boolean followReferrals;

	  /** Whether to connection allocation should include a bind attempt. */
	  private boolean autoBind;

	  /** Whether connection pooling is used. */
	  private boolean pooling = true;

	  /** Maximum number of connections to allow, if pooling is used. */
	  private int poolMaxConns = 10;

	/** connection allocation configuration */
	protected LdapConnectionManagerConfig config;

	private PooledConnectionFactory connFactory;

	/**
	 * {@inheritDoc}
	 */
	public void init() {
		log.debug("init()");

		String connectionString = config.isSecureConnection()?"ldaps://":"ldap://";
		connectionString += config.getLdapHost();
		connectionString += ":"+config.getLdapPort();
		
		SoftLimitConnectionPool pool = new SoftLimitConnectionPool(
				new DefaultConnectionFactory(connectionString));
		pool.initialize();
		
		this.connFactory = new PooledConnectionFactory(pool);

		verifySetup();
	}

	/**
	 * {@inheritDoc}
	 */
	public Connection getConnection() throws LdapException {
		log.debug("getConnection()");

		verifySetup();

		Connection conn = newConnection();

		return conn;
	}

	protected Connection newConnection() throws LdapException {
		verifySetup();

		return connFactory.getConnection();
	}

	/**
	 * {@inheritDoc}
	 */
	public void returnConnection(Connection conn) {
		try {
			if (conn != null) {
				conn.close();
			}
		} catch (Exception e) {
			log.error("returnConnection(): failed on disconnect: ", e);
		}
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param config
	 *            a reference to a {@link LdapConnectionManagerConfig}. Should
	 *            be cacheable without defensive copying.
	 */
	public void setConfig(LdapConnectionManagerConfig config) {
		this.config = config;
	}

	/**
	 * {@inheritDoc}
	 */
	public LdapConnectionManagerConfig getConfig() {
		return config;
	}


	private void verifySetup() throws IllegalStateException {
		if (config == null) {
			throw new IllegalStateException("Configuration not available for this connection manager.");
		}

		if (config.getKeystoreLocation() != null && config.getKeystoreLocation().length() > 0
				&& !(new File(config.getKeystoreLocation()).exists())) {
			throw new IllegalStateException(
					"Keystore not found at specified location [" + config.getKeystoreLocation() + "]");
		}
	}
}
