package org.conxworks.paas.naminganddirectory.ldaptive.resolver;

import java.util.Iterator;

import org.ldaptive.Connection;
import org.ldaptive.DnParser;
import org.ldaptive.LdapEntry;
import org.ldaptive.LdapException;
import org.ldaptive.ReturnAttributes;
import org.ldaptive.SearchFilter;
import org.ldaptive.SearchOperation;
import org.ldaptive.SearchRequest;
import org.ldaptive.SearchResult;
import org.ldaptive.SearchScope;
import org.ldaptive.auth.PooledSearchDnResolver;

public class MultiPartitionedLDAPPooledSearchDnResolver extends
		PooledSearchDnResolver {
	  /** Whether to enable multi partition support. */
	  private boolean supportMultiPartition;

	  /** Number of parts in subdomain. */
	  private int subdomainPartsLength;
	  
	  /**
	   * Attempts to find the DN for the supplied user. {@link #getUserFilter()} is
	   * used to look up the DN. The user is provided as the 'user' variable filter
	   * parameter. If more than one entry matches the search, the result is
	   * controlled by {@link #setAllowMultipleDns(boolean)}.
	   *
	   * @param  user  to find DN for
	   *
	   * @return  user DN
	   *
	   * @throws  LdapException  if the entry resolution fails
	   */
	  @Override
	  public String resolve(final String user)
	    throws LdapException
	  {
	    logger.debug("mp resolve user={}", user);

	    String dn = null;
	    if (user != null && !"".equals(user)) {
	      // create the search filter
	      final SearchFilter filter = createSearchFilter(user);

	      if (filter.getFilter() != null) {
	        final SearchResult result = performLdapSearch(filter,user,false);
	        if (result == null) {
	            logger.debug(
	  	              "user lookup failed",
	  	              user,
	  	              filter);	  
	            throw new LdapException("Failed to find user={}: " + user);
	        }
	        	
	        
	        final Iterator<LdapEntry> answer = result.getEntries().iterator();

	        // return first match, otherwise user doesn't exist
	        if (answer != null && answer.hasNext()) {
	          dn = resolveDn(answer.next());
	          if (answer.hasNext()) {
	            logger.debug(
	              "multiple results found for user={} using filter={}",
	              user,
	              filter);
	            if (!getAllowMultipleDns()) {
	              throw new LdapException("Found more than (1) DN for: " + user);
	            }
	          }
	        } else {
	          logger.info(
	            "search for user={} failed using filter={}",
	            user,
	            filter);
	        }
	      } else {
	        logger.error("DN search filter not found, no search performed");
	      }
	    } else {
	      logger.warn("DN resolution cannot occur, user input was empty or null");
	    }
	    logger.debug("resolved dn={} for user={}", dn, user);
	    return dn;
	  }

	  /**
	   * Executes the ldap search operation with the supplied filter.
	   *
	   * @param  filter  to execute
	   *
	   * @return  ldap search result
	   *
	   * @throws  LdapException  if an error occurs
	   */
	  protected SearchResult performLdapSearch(final SearchFilter filter, final String user, final boolean rootSearch)
	    throws LdapException
	  {
	    SearchRequest request;
		try {
			request = createSearchRequest(filter, user, rootSearch);
		} catch (DomainNotFoundException e) {
			logger.warn("performLdapSearch domain not found for user={} in forest", user);
			return null;
		}
	    
	    Connection conn = null;
	    try {
	      conn = getConnection();

	      final SearchOperation op = createSearchOperation(conn);
	      return op.execute(request).getResult();
	    } finally {
	      if (conn != null) {
	        conn.close();
	      }
	    }
	  }	  
	  
	  /**
	   * Returns a search request for searching for a single entry in an LDAP,
	   * returning no attributes.
	   *
	   * @param  filter  to execute
	   *
	   * @return  search request
	 * @throws DomainNotFoundException 
	   */
	  protected SearchRequest createSearchRequest(final SearchFilter filter, final String user, boolean rootSearch) throws DomainNotFoundException
	  {
	    final SearchRequest request = new SearchRequest();
	    
	    
	    if (!rootSearch) {
	    	String baseDn = this.getBaseDn(user);
	    	if (baseDn == null)
	    		throw new DomainNotFoundException();
	    		
			request.setBaseDn(baseDn);
		    if (getSubtreeSearch()) {
		      request.setSearchScope(SearchScope.SUBTREE);
		    } else {
		      request.setSearchScope(SearchScope.ONELEVEL);
		    }
	    }
	    else {
	    	request.setBaseDn("");
	    	request.setSearchScope(SearchScope.SUBTREE);
	    }
	    request.setSearchFilter(filter);
	    request.setReturnAttributes(ReturnAttributes.NONE.value());
	    request.setDerefAliases(getDerefAliases());
	    request.setFollowReferrals(getFollowReferrals());
	    return request;
	  }
	  
	  /**
	   * Returns the base DN.
	   *
	   * @return  base DN
	   */
	  public String getBaseDn(String user)
	  {
	    logger.debug("mp find user={} in forest", user);
	    String userDn = null;
	    try {
			userDn = lookupUserDomain(user);
			logger.debug("mp found user={} with domain={} in forest", user, userDn);
		} catch (LdapException e) {
			e.printStackTrace();
			return "";
		}
	    return userDn;
	  }

	private String lookupUserDomain(String user) throws LdapException {
	    logger.debug("mp lookupUserDomain user={}", user);

	    String dn = null;
	    if (user != null && !"".equals(user)) {
	      // create the search filter
	      final SearchFilter filter = createSearchFilter(user);

	      if (filter.getFilter() != null) {
	        final SearchResult result = performLdapSearch(filter,user,true);
	        final Iterator<LdapEntry> answer = result.getEntries().iterator();

	        // return first match, otherwise user doesn't exist
	        if (answer != null && answer.hasNext()) {
	          dn = resolveDn(answer.next());
	          if (answer.hasNext()) {
	            logger.debug(
	              "lookupUserDomain multiple results found for user={} using filter={}",
	              user,
	              filter);
	            if (!getAllowMultipleDns()) {
	              throw new LdapException("lookupUserDomain Found more than (1) DN for: " + user);
	            }
	          }
	        } else {
	          logger.info(
	            "lookupUserDomain search for user={} failed using filter={}",
	            user,
	            filter);
	          
	          return null;
	        }
	      } else {
	        logger.error("lookupUserDomain DN search filter not found, no search performed");
	        return null;
	      }
	    } else {
	      logger.warn("lookupUserDomain DN resolution cannot occur, user input was empty or null");
	      return null;
	    }
	    logger.debug("lookupUserDomain found user={} with dn={}", user, dn);
	    
	    String baseDn = DnParser.substring(dn, 2);
		logger.debug("lookupUserDomain dn={} resolved to domain={}", dn, baseDn);
	    
	    return baseDn;
	}

	public boolean getSupportMultiPartition() {
		return supportMultiPartition;
	}

	public void setSupportMultiPartition(boolean supportMultiPartition) {
	    logger.trace("setting supportMultiPartition: {}", supportMultiPartition);
		this.supportMultiPartition = supportMultiPartition;
	}

	public int getSubdomainPartsLength() {
		return subdomainPartsLength;
	}

	public void setSubdomainPartsLength(int subdomainPartsLength) {
		logger.trace("setting subdomainPartsLength: {}", subdomainPartsLength);
		this.subdomainPartsLength = subdomainPartsLength;
	}	  
}
