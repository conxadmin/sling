/**
 * Licensed to the Sakai Foundation (SF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The SF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
package org.sakaiproject.nakamura.ldap;

import org.apache.sling.contrib.ldap.api.LdapConnectionManager;
import org.apache.sling.contrib.ldap.api.LdapConnectionManagerConfig;
import org.ldaptive.Connection;
import org.ldaptive.DefaultConnectionFactory;
import org.ldaptive.LdapException;
import org.ldaptive.pool.PooledConnectionFactory;
import org.ldaptive.pool.SoftLimitConnectionPool;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.UnsupportedEncodingException;

/**
 */
public class PoolingLdapConnectionManager implements LdapConnectionManager {

	/** Class-specific logger */
	private static Logger log = LoggerFactory.getLogger(PoolingLdapConnectionManager.class);

	/** connection allocation configuration */
	protected LdapConnectionManagerConfig config;

	private PooledConnectionFactory connFactory;

	/**
	 * {@inheritDoc}
	 */
	public void init() {
		log.debug("init()");

		String connectionString = config.isSecureConnection()?"ldaps://":"ldap://";
		connectionString += config.getLdapHost();
		connectionString += ":"+config.getLdapPort();
		
		SoftLimitConnectionPool pool = new SoftLimitConnectionPool(
				new DefaultConnectionFactory(connectionString));
		pool.initialize();
		
		this.connFactory = new PooledConnectionFactory(pool);

		verifySetup();
	}

	/**
	 * {@inheritDoc}
	 */
	public Connection getConnection() throws LdapException {
		log.debug("getConnection()");

		verifySetup();

		Connection conn = newConnection();
		applyConstraints(conn);
		connect(conn);

		if (config.isAutoBind()) {
			log.debug("getConnection(): auto-binding");
			bind(conn, config.getLdapUser(), config.getLdapPassword());
		}

		return conn;
	}

	public Connection getBoundConnection(String dn, String pass) throws LdapException {
		verifySetup();

		log.debug("getBoundConnection(): [dn = {}]", config.getLdapUser());

		Connection conn = newConnection();
		applyConstraints(conn);
		connect(conn);
		bind(conn, dn, pass);

		return conn;
	}

	protected Connection newConnection() throws LdapException {
		verifySetup();

		return connFactory.getConnection();
	}

	/**
	 * {@inheritDoc}
	 */
	public void returnConnection(Connection conn) {
		try {
			if (conn != null) {
				conn.close();
			}
		} catch (Exception e) {
			log.error("returnConnection(): failed on disconnect: ", e);
		}
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param config
	 *            a reference to a {@link LdapConnectionManagerConfig}. Should
	 *            be cacheable without defensive copying.
	 */
	public void setConfig(LdapConnectionManagerConfig config) {
		this.config = config;
	}

	/**
	 * {@inheritDoc}
	 */
	public LdapConnectionManagerConfig getConfig() {
		return config;
	}

	/**
	 * Applies {@link LDAPConstraints} to the specified {@link Connection}.
	 * Implemented to assign <code>timeLimit</code> and
	 * <code>referralFollowing</code> constraint values retrieved from the
	 * currently assigned {@link LdapConnectionManagerConfig}.
	 *
	 * @param conn
	 */
	protected void applyConstraints(Connection conn) {
		verifySetup();

		int timeout = config.getOperationTimeout();
		boolean followReferrals = config.isFollowReferrals();
		log.debug("applyConstraints(): values [timeout = {}][follow referrals = {}]", timeout, followReferrals);
		LDAPConstraints constraints = new LDAPConstraints();
		constraints.setTimeLimit(timeout);
		constraints.setReferralFollowing(followReferrals);
		conn.setConstraints(constraints);
	}

	/**
	 * Connects the specified <code>Connection</code> to the currently
	 * configured host and port.
	 *
	 * @param conn
	 *            an <code>Connection</code>
	 * @throws Connection
	 *             if the connect attempt fails
	 */
	protected void connect(Connection conn) throws LdapException {
		log.debug("connect()");

		verifySetup();

		conn.connect(config.getLdapHost(), config.getLdapPort());

		try {
			postConnect(conn);
		} catch (LdapException e) {
			log.error("Failed to completely initialize a connection [host = " + config.getLdapHost() + "][port = "
					+ config.getLdapPort() + "]", e);
			try {
				conn.disconnect();
			} catch (LdapException ee) {
			}

			throw e;
		} catch (Throwable e) {
			log.error("Failed to completely initialize a connection [host = " + config.getLdapHost() + "][port = "
					+ config.getLdapPort() + "]", e);
			try {
				conn.disconnect();
			} catch (LdapException ee) {
			}

			if (e instanceof Error) {
				throw (Error) e;
			}
			if (e instanceof RuntimeException) {
				throw (RuntimeException) e;
			}

			throw new RuntimeException("Connection allocation failure", e);
		}

	}

	protected void postConnect(Connection conn) throws LdapException {

		log.debug("postConnect()");

		verifySetup();

		if (config.isSecureConnection() && config.isTLS()) {
			log.debug("postConnect(): starting TLS");
			conn.startTLS();
		}
	}

	private void verifySetup() throws IllegalStateException {
		if (config == null) {
			throw new IllegalStateException("Configuration not available for this connection manager.");
		}

		if (config.getKeystoreLocation() != null && config.getKeystoreLocation().length() > 0
				&& !(new File(config.getKeystoreLocation()).exists())) {
			throw new IllegalStateException(
					"Keystore not found at specified location [" + config.getKeystoreLocation() + "]");
		}
	}
}
